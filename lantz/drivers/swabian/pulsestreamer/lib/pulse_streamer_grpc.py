# import grpc-package
import sys

from grpc import insecure_channel

# from time import *

try:
    # import the python wrapper generated by the protocol buffer compiler (source: pulse_streamer.proto)
    from lantz.drivers.swabian.pulsestreamer.lib.pulse_streamer_pb2 import VoidMessage, PulseMessage, SequenceMessage, \
        ClockMessage, DrpClkSetMessage, GetSerialMessage, TriggerMessage, SetNetworkMessage, EnableStaticIPMessage, \
        PulseStreamerStub
except Exception as e:
    print('Exception: ' + str(e))
    print(
        """
        Failed to import simple wrapper generated by the protobuf compiler (source: pulse_streamer.proto)
        - Ensure pulse_streamer_pb2.py is in the search path.
        Required packages: grpcio, protobuf
        """)
    sys.exit(1)

import numpy as np
from enum import Enum


class Serial(Enum):
    ID = 0
    MAC = 1


class Clock_source(Enum):
    INTERNAL = 0
    EXT_125MHZ = 1
    EXT_10MHZ = 2


class Start(Enum):
    IMMEDIATE = 0
    SOFTWARE = 1
    HARDWARE_RISING = 2
    HARDWARE_FALLING = 3
    HARDWARE_RISING_AND_FALLING = 4


class Mode(Enum):
    NORMAL = 0
    SINGLE = 1


class PulseStreamer():
    """
    Simple python wrapper for a PulseStreamer 8/2
    that describes pulses in the form (time, ['ch0', 'ch3'], 0.8, -0.4),
    where time is an integer in ns (clock ticks),
    ['ch0','ch3'] is a list naming the channels that should be high
    the last two numbers specify the analog outputs in volt.
    """

    TIMEOUT = 200

    def __init__(self, ip_hostname='pulsestreamer'):
        print("Connect to Pulse Streamer via google-RPC.")
        print("IP / Hostname:", ip_hostname)

        self.INFINITE = -1
        self.CONSTANT_ZERO = (0, 0, 0, 0)

        try:
            channel = insecure_channel(ip_hostname + ':50051')
            self.stub = PulseStreamerStub(channel)
            try:
                g = GetSerialMessage()
                g.serial = getattr(GetSerialMessage, Serial.MAC.name)
                self.stub.getSerial(g, timeout=PulseStreamer.TIMEOUT)
            except:
                try:
                    void = VoidMessage()
                    self.stub.isRunning(void, timeout=PulseStreamer.TIMEOUT)
                    print("Pulse Streamer class not compatible with current firmware. Please update your firmware.")
                    sys.exit(1)
                except:
                    print("No Pulse Streamer found at IP/Host-address: " + ip_hostname)
                    sys.exit(1)
        except:
            print("No Pulse Streamer found at IP/Host-address: " + ip_hostname)
            sys.exit(1)

    def reset(self):
        void = VoidMessage()
        return self.stub.reset(void, timeout=PulseStreamer.TIMEOUT)

    def constant(self, pulse):
        if (pulse == 'CONSTANT_ZERO' or pulse == 'constant_zero'):
            t, chans, a0, a1 = self.CONSTANT_ZERO
            pulse = PulseMessage(ticks=t, digi=chans, ao0=a0, ao1=a1)
        else:
            if isinstance(pulse[1], list):
                pulse = self.convert_pulse(pulse)
            else:
                t, chans, a0, a1 = pulse
                pulse = PulseMessage(ticks=t, digi=chans, ao0=a0, ao1=a1)
        self.stub.constant(pulse, timeout=PulseStreamer.TIMEOUT)

    def forceFinal(self):
        void = VoidMessage()
        self.stub.forceFinal(void, timeout=PulseStreamer.TIMEOUT)

    def stream(self, seq, n_runs='INFINITE', final='CONSTANT_ZERO'):
        check = list(filter(lambda x: abs(x[2]) >= 2 ** 15 or abs(x[3]) >= 2 ** 15, seq))
        if check != []:
            print(""" Failed because of wrong range of pulse_data 
            The range of analog channel values is -32768 to 32768 (int_16t)
            """)
            sys.exit()

        s = SequenceMessage()
        if type(seq[0][1]) == list:
            for i in range(len(seq)):
                s.pulse.extend([self.convert_pulse(seq[i])])
        else:
            for i in range(len(seq)):
                t, chans, a0, a1 = seq[i]
                s.pulse.extend([PulseMessage(ticks=t, digi=chans, ao0=a0, ao1=a1)])

        if (n_runs == 'INFINITE' or n_runs == 'infinite'):
            n_runs = self.INFINITE

        s.n_runs = n_runs

        if (final == 'CONSTANT_ZERO' or final == 'constant_zero'):
            t, chans, a0, a1 = self.CONSTANT_ZERO
            conv_final = PulseMessage(ticks=t, digi=chans, ao0=a0, ao1=a1)
        else:
            if isinstance(final[1], list):
                conv_final = self.convert_pulse(final)
            else:
                t, chans, a0, a1 = final
                conv_final = PulseMessage(ticks=t, digi=chans, ao0=a0, ao1=a1)

        s.final.ticks = conv_final.ticks
        s.final.digi = conv_final.digi
        s.final.ao0 = conv_final.ao0
        s.final.ao1 = conv_final.ao1

        self.stub.stream(s, timeout=PulseStreamer.TIMEOUT)

    def isStreaming(self):
        void = VoidMessage()
        return self.stub.isStreaming(void, timeout=PulseStreamer.TIMEOUT).value

    def hasSequence(self):
        void = VoidMessage()
        return self.stub.hasSequence(void, timeout=PulseStreamer.TIMEOUT).value

    def hasFinished(self):
        void = VoidMessage()
        return self.stub.hasFinished(void, timeout=PulseStreamer.TIMEOUT).value

    def startNow(self):
        void = VoidMessage()
        return self.stub.startNow(void, timeout=PulseStreamer.TIMEOUT).value

    def selectClock(self, clock_source):
        if not isinstance(clock_source, Clock_source):
            raise TypeError("clock_source must be an instance of Clock_source Enum")
        else:
            c = ClockMessage()
            c.clock_source = getattr(ClockMessage, clock_source.name)
            return self.stub.selectClock(c, timeout=PulseStreamer.TIMEOUT).value

    def getFirmwareVersion(self):
        void = VoidMessage()
        return self.stub.getFirmwareVersion(void, timeout=PulseStreamer.TIMEOUT).string_value

    def flash_lic(self):
        void = VoidMessage()
        return self.stub.flash_lic(void, timeout=PulseStreamer.TIMEOUT).string_value

    def getSerial(self, serial=Serial.MAC):
        if not isinstance(serial, Serial):
            raise TypeError("serial must be an instance of Serial Enum")
        else:
            g = GetSerialMessage()
            g.serial = getattr(GetSerialMessage, serial.name)
            return self.stub.getSerial(g, timeout=PulseStreamer.TIMEOUT).string_value

    def setClkParam(self, value=0):
        assert value in range(58)
        v = DrpClkSetMessage()
        v.value = value
        return self.stub.setClkParam(v, timeout=PulseStreamer.TIMEOUT).value

    def setTrigger(self, start, mode=Mode.NORMAL):
        if not isinstance(start, Start):
            raise TypeError("start must be an instance of Start Enum")
        else:
            if not isinstance(mode, Mode):
                raise TypeError("mode must be an instance of Mode Enum")
            else:
                t = TriggerMessage()
                t.start = getattr(TriggerMessage, start.name)
                t.mode = getattr(TriggerMessage, mode.name)
                return self.stub.setTrigger(t, timeout=PulseStreamer.TIMEOUT).value

    def rearm(self):
        void = VoidMessage()
        return self.stub.rearm(void, timeout=PulseStreamer.TIMEOUT).value

    def setNetworkConf(self, ip, netmask, gateway):
        n = SetNetworkMessage()
        n.ip = ip
        n.netmask = netmask
        n.gateway = gateway
        return self.stub.setNetworkConf(n, timeout=PulseStreamer.TIMEOUT).string_value

    def getNetworkConf(self):
        void = VoidMessage()
        return self.stub.getNetworkConf(void, timeout=PulseStreamer.TIMEOUT).string_value

    def testNetworkConf(self):
        void = VoidMessage()
        return self.stub.testNetworkConf(void, timeout=PulseStreamer.TIMEOUT).value

    def enableStaticIP(self, permanent=False):
        assert permanent in [True, False]
        e = EnableStaticIPMessage()
        e.permanent = permanent
        return self.stub.enableStaticIP(e, timeout=PulseStreamer.TIMEOUT).string_value

    def getUnderflow(self):
        void = VoidMessage()
        return self.stub.getUnderflow(void, timeout=PulseStreamer.TIMEOUT).value

    def getDebugRegister(self):
        void = VoidMessage()
        return self.stub.getDebugRegister(void, timeout=PulseStreamer.PulseStreamer.TIMEOUT).value

    def convert_pulse(self, pulse):
        t, chans, a0, a1 = pulse

        p = PulseMessage(ticks=t, digi=self.chans_to_mask(chans), ao0=int(round(0x7fff * a0)),
                         ao1=int(round(0x7fff * a1)))
        if p.digi >= 2 ** 8:
            print(""" Failed because of wrong range of pulse_data 
            The range of digital channel mask is 255 (byte)
            """)
            sys.exit()
        return p

    def chans_to_mask(self, chans):
        mask = 0
        for chan in chans:
            mask |= 1 << chan
        return mask


def get_random_seq(min_len=0, max_len=1024, n_pulses=1000):
    """
    Generate a sequence of random pulses on the digital
    channels 1-7 and the two analog channels.

    Digital channel 0 is used as a trigger.    
    """
    t = np.random.uniform(min_len, max_len, n_pulses).astype(int)
    seq = [(8, [0], 0, 0)]  # 8 ns trigger pulse on channel 0
    for i, ti in enumerate(t):
        state = i % 2
        seq += [(ti, state * [i for i in range(1, 8)], 1.0 * state, -1.0 * state)]
    return seq


"""---------Test-Code-------------------------------"""

if __name__ == '__main__':
    pulser = PulseStreamer(ip_hostname='pulsestreamer')

    print("Serial number:", pulser.getSerial())
    print("Firmware Version:", pulser.getFirmwareVersion())

    pulser.stream(get_random_seq())
    print(get_random_seq())
